//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Common Issues
// Solutions to common problems : https://github.com/nRF24/RF24/blob/master/COMMON_ISSUES.md
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 01_nRF24L01_Test_Send

// Code source : https://forum.arduino.cc/t/simple-nrf24l01-2-4ghz-transceiver-demo/405123/2 (By Robin2).

//----------------------------------------Including the libraries.
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
//----------------------------------------

// Defines CE and CSN PINs.
#define CE_PIN  9
#define CSN_PIN 10

// Address through which two modules communicate.
const byte Pipe_Address[6] = "00001";

// Variable for the data sending timer.
unsigned long previousMillis = 0;
unsigned long sendIntervalMillis = 1000; // Interval of sending data (1000 ms = 1 second).

// Variables to hold the data to be sent.
// The maximum data length that can be transmitted by the nRF24L01 module is 32 bytes.
char dataToSend[32] = "";

byte count = 0;

// Create an RF24 object as a radio, while also setting the CE and CSN PINs.
RF24 radio(CE_PIN, CSN_PIN); // CE, CSN

//________________________________________________________________________________VOID SETUP()
void setup() {
  // put your setup code here, to run once:
  
  Serial.begin(115200);
  Serial.println();
  delay(2000);

  Serial.println("This is the Sender.");

  // initialize the radio object.
  radio.begin();

  // set the Power Amplifier level.
  // Use "RF24_PA_MIN" or "RF24_PA_LOW" if the distance between nRF24L01 modules is close to each other.
  // Use "RF24_PA_HIGH" or "RF24_PA_MAX" if the distance between nRF24L01 modules is far from each other.
  // For more details, see here : https://github.com/nRF24/RF24/blob/master/RF24.h#L26C1-L26C1
  radio.setPALevel(RF24_PA_LOW);
  
  // Set the transmission datarate.
  radio.setDataRate(RF24_250KBPS); // (RF24_250KBPS|RF24_1MBPS|RF24_2MBPS).

  // Set the number and delay of retries upon failed submit.
  radio.setRetries(5,5); // setRetries(delay,count).

  // Set the nRF24L01 module as the sender.
  radio.stopListening();

  // Set the address to send data to the receiver. The receiver must use the same address.
  radio.openWritingPipe(Pipe_Address);

  // Prepare data to be sent.
  sprintf(dataToSend, "Message %d",  count);
}
//________________________________________________________________________________

//________________________________________________________________________________VOID LOOP()
void loop() {
  // put your main code here, to run repeatedly:
  
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= sendIntervalMillis) {
    previousMillis = currentMillis;
    
    // Calls the send() subroutine.
    send_Data();
  }
}
//________________________________________________________________________________

//________________________________________________________________________________send_Data()
// Subroutine for sending data.
void send_Data() { 
  bool rslt;

  // Always use sizeof() as it gives the size as the number of bytes.
  // For example if dataToSend was an int sizeof() would correctly return 2
  rslt = radio.write(&dataToSend, sizeof(dataToSend));

  Serial.print("Data Sent : ");
  Serial.print(dataToSend);
  if (rslt) {
    Serial.println(" | Acknowledge received");
    update_Message();
  }
  else {
    Serial.println(" | Failed to send data !");
  }
}
//________________________________________________________________________________

//________________________________________________________________________________update_Message()
void update_Message() {
  count++;
  if (count > 9) count = 0;

  sprintf(dataToSend, "Message %d",  count);
}
//________________________________________________________________________________
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 02_nRF24L01_Test_Receive

// Code source : https://forum.arduino.cc/t/simple-nrf24l01-2-4ghz-transceiver-demo/405123/2 (By Robin2).

//----------------------------------------Including the libraries.
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
//----------------------------------------

// Defines CE and CSN PINs.
#define CE_PIN  9
#define CSN_PIN 10

// Address through which two modules communicate.
const byte Pipe_Address[6] = "00001";

// Variables to hold the data to be received.
// this must match "dataToSend" in the sender.
char dataReceived[32] = ""; 

// Variables to detect new incoming data.
bool newData = false;

// Create an RF24 object as a radio, while also setting the CE and CSN PINs.
RF24 radio(CE_PIN, CSN_PIN);

//________________________________________________________________________________VOID SETUP()
void setup() {
  // put your setup code here, to run once:
  
  Serial.begin(115200);
  Serial.println();
  delay(2000);

  Serial.println("This is the Receiver.");

  // initialize the radio object.
  radio.begin();

  // set the Power Amplifier level.
  // Use "RF24_PA_MIN" or "RF24_PA_LOW" if the distance between nRF24L01 modules is close to each other.
  // Use "RF24_PA_HIGH" or "RF24_PA_MAX" if the distance between nRF24L01 modules is far from each other.
  // For more details, see here : https://github.com/nRF24/RF24/blob/master/RF24.h#L26C1-L26C1
  radio.setPALevel(RF24_PA_LOW);

  // Set the transmission datarate.
  radio.setDataRate(RF24_250KBPS);

  // Set the address to receive data from the sender. The sender must use the same address.
  radio.openReadingPipe(0, Pipe_Address);

  // Set the nRF24L01 module as the receiver.
  radio.startListening();
}
//________________________________________________________________________________

//________________________________________________________________________________VOID LOOP()
void loop() {
  // put your main code here, to run repeatedly:

  // Calling the receive_Data() subroutine.
  receive_Data();

  // Calling the show_Data() subroutine.
  show_Data();
}
//________________________________________________________________________________

//________________________________________________________________________________receive_Data()
// Subroutine for receiving data.
void receive_Data() {
  if (radio.available()) {
    radio.read(&dataReceived, sizeof(dataReceived));
    newData = true;
  }
}
//________________________________________________________________________________

//________________________________________________________________________________show_Data()
// Subroutine for printing the received data to the serial monitor (serial communication).
void show_Data() {
  if (newData == true) {
    Serial.print("Data received : ");
    Serial.println(dataReceived);
    newData = false;
  }
}
//________________________________________________________________________________
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 03_nRF24L01_Bi-directional_Communication_Arduino_UNO_A

// Reference : https://forum.arduino.cc/t/simple-nrf24l01-2-4ghz-transceiver-demo/405123/4

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Arduino_UNO_A sends data to Arduino_UNO_B.                                                             //
// After Arduino_UNO_B receives data from Arduino_UNO_A, Arduino_UNO_B sends reply data to Arduino_UNO_A. //
////////////////////////////////////////////////////////////////////////////////////////////////////////////

//----------------------------------------Including the libraries.
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
//----------------------------------------

// Defines CE and CSN PINs.
#define CE_PIN  9
#define CSN_PIN 10

//----------------------------------------Address through which two modules communicate.
//////////////////////////////////////////////////////////////////
// Arduino_UNO_A ----(Pipe_Address_1=00001)----> Arduino_UNO_B  //
// Arduino_UNO_A <---(Pipe_Address_2=00002)----- Arduino_UNO_B  //
//////////////////////////////////////////////////////////////////
const byte Pipe_Address_1[6] = "00001";
const byte Pipe_Address_2[6] = "00002";
//----------------------------------------

// Variable for the data sending timer.
unsigned long previousMillis = 0;
unsigned long sendIntervalMillis = 5000; // Interval of sending data (5000 ms = 5 second).

// Variables to hold the data to be sent.
// The maximum data length that can be transmitted by the nRF24L01 module is 32 bytes.
char dataToSend[32] = "";

// Variables to hold the data to be received.
// The number of char arrays must match the number of char arrays in the "dataToSend" variable in the sender.
char dataReceived[32]= ""; 

// Variables to detect new incoming data.
bool newData = false;

byte count = 0;

// Create an RF24 object as a radio, while also setting the CE and CSN PINs.
RF24 radio(CE_PIN, CSN_PIN); // CE, CSN

//________________________________________________________________________________VOID SETUP()
void setup() {
  // put your setup code here, to run once:

  Serial.begin(115200);
  Serial.println();
  delay(2000);

  Serial.println("This is Arduino_UNO_A");
  Serial.println();

  // initialize the radio object.
  radio.begin();

  // set the Power Amplifier level.
  // Use "RF24_PA_MIN" or "RF24_PA_LOW" if the distance between nRF24L01 modules is close to each other.
  // Use "RF24_PA_HIGH" or "RF24_PA_MAX" if the distance between nRF24L01 modules is far from each other.
  // For more details, see here : https://github.com/nRF24/RF24/blob/master/RF24.h#L26C1-L26C1
  radio.setPALevel(RF24_PA_LOW);
  
  // Set the transmission datarate.
  radio.setDataRate(RF24_250KBPS); // (RF24_250KBPS|RF24_1MBPS|RF24_2MBPS).

  // Set the number and delay of retries upon failed submit.
  radio.setRetries(5,5); // setRetries(delay,count).

  // Set the nRF24L01 module as the sender.
  radio.stopListening();

  // Set the address to send data to the receiver. The receiver must use the same address.
  // Arduino_UNO_A ----(Pipe_Address_1=00001)----> Arduino_UNO_B
  radio.openWritingPipe(Pipe_Address_1);

  // Set the address to receive data from the sender. The sender must use the same address.
  // Arduino_UNO_A <---(Pipe_Address_2=00002)----- Arduino_UNO_B
  radio.openReadingPipe(1, Pipe_Address_2);

  // Prepare data to be sent.
  sprintf(dataToSend, "Count %d",  count);
}
//________________________________________________________________________________

//________________________________________________________________________________VOID LOOP()
void loop() {
  // put your main code here, to run repeatedly:

  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= sendIntervalMillis) {
    previousMillis = currentMillis;

    // Calls the send_Data() subroutine.
    send_Data();
  }

  // Calling the receive_Data() subroutine.
  receive_Data();

  // Calling the show_Data() subroutine.
  show_Data();
}
//________________________________________________________________________________

//________________________________________________________________________________send_Data()
// Subroutine for sending data.
void send_Data() {
  //----------------------------------------
  // Set the nRF24L01 module as the sender.
  radio.stopListening();
  
  bool rslt;

  // Always use sizeof() as it gives the size as the number of bytes.
  // For example if dataToSend was an int sizeof() would correctly return 2
  rslt = radio.write(&dataToSend, sizeof(dataToSend));
  //----------------------------------------

  //----------------------------------------
  Serial.print("Arduino_UNO_A | Data Sent : ");
  Serial.print(dataToSend);
  if (rslt) {
    Serial.println(" | Acknowledge received");
    update_Message();
  }
  else {
    Serial.println(" | Failed to send data !");
  }
  //----------------------------------------
}
//________________________________________________________________________________

//________________________________________________________________________________update_Message()
void update_Message() {
  count++;
  if (count > 9) count = 0;

  sprintf(dataToSend, "Count %d",  count);
}
//________________________________________________________________________________

//________________________________________________________________________________receive_Data()
// Subroutine for receiving data.
void receive_Data() {
  // Set the nRF24L01 module as the receiver.
  radio.startListening();
  
  if (radio.available()) {
    radio.read( &dataReceived, sizeof(dataReceived) );
    newData = true;
  }
}
//________________________________________________________________________________

//________________________________________________________________________________show_Data()
// Subroutine for printing the received data to the serial monitor (serial communication).
void show_Data() {
  if (newData == true) {
    Serial.print("Arduino_UNO_A | Data received : ");
    Serial.println(dataReceived);
    Serial.println();
    newData = false;
  }
}
//________________________________________________________________________________
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 04_nRF24L01_Bi-directional_Communication_Arduino_UNO_B

// Reference : https://forum.arduino.cc/t/simple-nrf24l01-2-4ghz-transceiver-demo/405123/4

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Arduino_UNO_A sends data to Arduino_UNO_B.                                                             //
// After Arduino_UNO_B receives data from Arduino_UNO_A, Arduino_UNO_B sends reply data to Arduino_UNO_A. //
////////////////////////////////////////////////////////////////////////////////////////////////////////////

//----------------------------------------Including the libraries.
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
//----------------------------------------

// Defines CE and CSN PINs.
#define CE_PIN  9
#define CSN_PIN 10

//----------------------------------------Address through which two modules communicate.
//////////////////////////////////////////////////////////////////
// Arduino_UNO_B ----(Pipe_Address_2=00002)----> Arduino_UNO_A  //
// Arduino_UNO_B <---(Pipe_Address_1=00001)----- Arduino_UNO_A  //
//////////////////////////////////////////////////////////////////
const byte Pipe_Address_1[6] = "00001";
const byte Pipe_Address_2[6] = "00002";
//----------------------------------------

// Variables to hold the data to be sent.
// The maximum data length that can be transmitted by the nRF24L01 module is 32 bytes.
char dataToSend[32] = "";

// Variables to hold the data to be received.
// The number of char arrays must match the number of char arrays in the "dataToSend" variable in the sender.
char dataReceived[32]= ""; 

// Variables to detect new incoming data.
bool newData = false;

int count = 9;

// Create an RF24 object as a radio, while also setting the CE and CSN PINs.
RF24 radio(CE_PIN, CSN_PIN); // CE, CSN

//________________________________________________________________________________VOID SETUP()
void setup() {
  // put your setup code here, to run once:

  Serial.begin(115200);
  Serial.println();
  delay(2000);

  Serial.println("This is Arduino_UNO_B");
  Serial.println();

  // initialize the radio object.
  radio.begin();

  // set the Power Amplifier level.
  // Use "RF24_PA_MIN" or "RF24_PA_LOW" if the distance between nRF24L01 modules is close to each other.
  // Use "RF24_PA_HIGH" or "RF24_PA_MAX" if the distance between nRF24L01 modules is far from each other.
  // For more details, see here : https://github.com/nRF24/RF24/blob/master/RF24.h#L26C1-L26C1
  radio.setPALevel(RF24_PA_LOW);
  
  // Set the transmission datarate.
  radio.setDataRate(RF24_250KBPS); // (RF24_250KBPS|RF24_1MBPS|RF24_2MBPS).

  // Set the number and delay of retries upon failed submit.
  radio.setRetries(5,5); // setRetries(delay,count).

  // Set the nRF24L01 module as the sender.
  radio.stopListening();

  // Set the address to send data to the receiver. The receiver must use the same address.
  // Arduino_UNO_B ----(Pipe_Address_2=00002)----> Arduino_UNO_A
  radio.openWritingPipe(Pipe_Address_2);

  // Set the address to receive data from the sender. The sender must use the same address.
  // Arduino_UNO_B <----(Pipe_Address_1=00001)---- Arduino_UNO_A
  radio.openReadingPipe(1, Pipe_Address_1);

  // Prepare data to be sent.
  sprintf(dataToSend, "Count %d",  count);
}
//________________________________________________________________________________

//________________________________________________________________________________VOID LOOP()
void loop() {
  // put your main code here, to run repeatedly:

  // Calling the receive_Data() subroutine.
  receive_Data();

  // Calling the show_Data() subroutine.
  show_Data();

  // Calls the send_Data() subroutine.
  send_Data();
}
//________________________________________________________________________________

//________________________________________________________________________________receive_Data()
// Subroutine for receiving data.
void receive_Data() {
  // Set the nRF24L01 module as the receiver.
  radio.startListening();
  
  if (radio.available()) {
    radio.read(&dataReceived, sizeof(dataReceived));
    newData = true;
  }
}
//________________________________________________________________________________

//________________________________________________________________________________show_Data()
// Subroutine for printing the received data to the serial monitor (serial communication).
void show_Data() {
  if (newData == true) {
    Serial.print("Arduino_UNO_B | Data received : ");
    Serial.println(dataReceived);
  }
}
//________________________________________________________________________________

//________________________________________________________________________________send_Data()
// Subroutine for sending data.
void send_Data() {
  // Conditions for sending data.
  // Arduino_UNO_B only sends data if it has received data from Arduino_UNO_A. 
  if (newData == true) {
    //----------------------------------------
    // Set the nRF24L01 module as the sender.
    radio.stopListening();
    
    bool rslt;
  
    // Always use sizeof() as it gives the size as the number of bytes.
    // For example if dataToSend was an int sizeof() would correctly return 2
    rslt = radio.write(&dataToSend, sizeof(dataToSend));
    //----------------------------------------
  
    //----------------------------------------
    Serial.print("Arduino_UNO_B | Data Sent : ");
    Serial.print(dataToSend);
    if (rslt) {
      Serial.println(" | Acknowledge received");
      Serial.println();
      update_Message();
    }
    else {
      Serial.println(" | Failed to send data !");
    }
    //----------------------------------------
  
    newData = false;
  }
}
//________________________________________________________________________________

//________________________________________________________________________________update_Message()
void update_Message() {
  count--;
  if (count < 0) count = 9;

  sprintf(dataToSend, "Count %d",  count);
}
//________________________________________________________________________________
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 05_Test_LCD_16x2_I2C_and_Switches
#include <LiquidCrystal_I2C.h>

// Defines the PIN for the Switches.
#define Switch_1_PIN 2
#define Switch_2_PIN 3

// Initialize the LiquidCrystal_I2C lib as "lcd" and set the LCD I2C address to 0x27 and set the LCD configuration to 16 x 2.
// In general, the address of a 16x2 I2C LCD is "0x27".
// However, if the address "0x27" doesn't work, you can find out the address with "i2c_scanner". Look here : https://playground.arduino.cc/Main/I2cScanner/
LiquidCrystal_I2C lcd(0x27,16,2);

void setup() {
  // put your setup code here, to run once:

  Serial.begin(115200);
  Serial.println();
  delay(1000);

  pinMode(Switch_1_PIN, INPUT_PULLUP);
  pinMode(Switch_2_PIN, INPUT_PULLUP);

  // Initialize lcd.
  lcd.init();
  // Turn on the LED backlight on the LCD.
  lcd.backlight();
  // Clean the LCD display.
  lcd.clear();
}

void loop() {
  // put your main code here, to run repeatedly:

  lcd.setCursor(0,0);
  lcd.print("Switch 1 : ");
  lcd.print(digitalRead(Switch_1_PIN));
  lcd.setCursor(0,1);
  lcd.print("Switch 2 : ");
  lcd.print(digitalRead(Switch_2_PIN));

  delay(1000);
}
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 06_Test_DHT11_and_LEDs

// Reference : https://github.com/adafruit/DHT-sensor-library/blob/master/examples/DHTtester/DHTtester.ino

// Includes DHT library.
#include "DHT.h"

// Defines the DHT11 PIN and DHT sensor type.
#define DHTPIN  4
#define DHTTYPE DHT11

// Defines the PIN for the LEDs.
#define LED_1_PIN   2
#define LED_2_PIN   3

DHT dht11(DHTPIN, DHTTYPE);

void setup() {
  // put your setup code here, to run once:

  Serial.begin(115200);
  Serial.println();

  pinMode(LED_1_PIN, OUTPUT);
  pinMode(LED_2_PIN, OUTPUT);

  digitalWrite(LED_1_PIN, LOW);
  digitalWrite(LED_2_PIN, LOW);
  
  Serial.println(F("LEDs and DHT11 test!"));

  dht11.begin();

  digitalWrite(LED_1_PIN, HIGH);
  digitalWrite(LED_2_PIN, LOW);
}

void loop() {
  // put your main code here, to run repeatedly:

  delay(2000);

  // Reading temperature or humidity takes about 250 milliseconds!
  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)
  int h = dht11.readHumidity();
  // Read temperature as Celsius (the default)
  float t = dht11.readTemperature();

  // Check if any reads failed and exit early (to try again).
  if (isnan(h) || isnan(t)) {
    Serial.println(F("Failed to read from DHT sensor!"));
    return;
  }

  Serial.print(F("Humidity : "));
  Serial.print(h);
  Serial.print(F("% | Temperature : "));
  Serial.print(t);
  Serial.println(F("°C"));

  digitalWrite(LED_1_PIN, !digitalRead(LED_1_PIN));
  digitalWrite(LED_2_PIN, !digitalRead(LED_2_PIN));
}
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 07_Final_Master (LCD_and_Switches)

// Reference : https://forum.arduino.cc/t/simple-nrf24l01-2-4ghz-transceiver-demo/405123/4

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The master sends data (state data of Switch_1 and Switch_2 to control LED_1 and LED_2 on the slave) to the slave.            //
// After the slave receives data from the master,                                                                               //
// the slave sends data (sensor reading status, temperature and humidity values obtained from the DHT11 sensor) to the master.  //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//----------------------------------------Including the libraries.
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
#include <LiquidCrystal_I2C.h>
//----------------------------------------

// Defines CE and CSN PINs.
#define CE_PIN  9
#define CSN_PIN 10

// Defines the PIN for the Switches.
#define Switch_1_PIN 2
#define Switch_2_PIN 3

// Defines the location number for the custom degree character to be displayed on the LCD.
#define degree_Char_Num 0

//----------------------------------------Address through which two modules communicate.
////////////////////////////////////////////////////
// Master ----(Pipe_Address_1=00001)----> Slave   //
// Master <---(Pipe_Address_2=00002)----- Slave   //
////////////////////////////////////////////////////
const byte Pipe_Address_1[6] = "00001";
const byte Pipe_Address_2[6] = "00002";
//----------------------------------------

// Variable for the data sending timer.
unsigned long previousMillis = 0;
unsigned long sendIntervalMillis = 3000; // Interval of sending data (3000 ms = 3 second).

//----------------------------------------Struct variables for sending and receiving data.
// Max size of this struct is 32 bytes - NRF24L01 buffer limit.
// This struct must match with the struct on the slave.

//::::::::::::::::::Variables to hold the data to be sent.
struct Data_Package_Send {
  bool Switch_1_State;
  bool Switch_2_State;
};
Data_Package_Send dataToSend; // Create a variable with the above structure.
//::::::::::::::::::

//::::::::::::::::::Variables to hold the data to be received.
struct Data_Package_Receive {
  bool  Status_Read_Sensor;
  float Temp;
  int   Humd;
};
Data_Package_Receive dataReceived; // Create a variable with the above structure.
//::::::::::::::::::
//----------------------------------------

// Variables to detect new incoming data.
bool newData = false;

// Byte array variable for custom degree characters.
byte degree_Char[] = {
  B00110,
  B01001,
  B01001,
  B00110,
  B00000,
  B00000,
  B00000,
  B00000
};

// Create an RF24 object as a radio, while also setting the CE and CSN PINs.
RF24 radio(CE_PIN, CSN_PIN); // CE, CSN

// Create a LiquidCrystal_I2C object as an LCD and set the LCD I2C address to 0x27 and set the LCD configuration to 16 x 2.
// In general, the address of a 16x2 I2C LCD is "0x27".
// However, if the address "0x27" doesn't work, you can find out the address with "i2c_scanner". Look here : https://playground.arduino.cc/Main/I2cScanner/
LiquidCrystal_I2C lcd(0x27,16,2);

//________________________________________________________________________________VOID SETUP()
void setup() {
  // put your setup code here, to run once:

  Serial.begin(115200);
  Serial.println();
  delay(2000);

  Serial.println("This is Master");
  Serial.println();

  pinMode(Switch_1_PIN, INPUT_PULLUP);
  pinMode(Switch_2_PIN, INPUT_PULLUP);

  //----------------------------------------LCD Setup.
  // Initialize lcd.
  lcd.init();
  // Turn on the LED backlight on the LCD.
  lcd.backlight();
  // Custom characters for degree symbols.
  lcd.createChar(degree_Char_Num, degree_Char);
  // Clean the LCD display.
  lcd.clear();
  //----------------------------------------

  //----------------------------------------nRF24L01 Setup.
  // initialize the radio object.
  radio.begin();

  // set the Power Amplifier level.
  // Use "RF24_PA_MIN" or "RF24_PA_LOW" if the distance between nRF24L01 modules is close to each other.
  // Use "RF24_PA_HIGH" or "RF24_PA_MAX" if the distance between nRF24L01 modules is far from each other.
  // For more details, see here : https://github.com/nRF24/RF24/blob/master/RF24.h#L26C1-L26C1
  radio.setPALevel(RF24_PA_LOW);
  
  // Set the transmission datarate.
  radio.setDataRate(RF24_250KBPS); // (RF24_250KBPS|RF24_1MBPS|RF24_2MBPS).

  // Set the number and delay of retries upon failed submit.
  radio.setRetries(5,5); // setRetries(delay,count).

  // Set the nRF24L01 module as the sender.
  radio.stopListening();

  // Set the address to send data to the receiver. The receiver must use the same address.
  // Master ----(Pipe_Address_1=00001)----> Slave
  radio.openWritingPipe(Pipe_Address_1);

  // Set the address to receive data from the sender. The sender must use the same address.
  // Master <---(Pipe_Address_2=00002)----- Slave
  radio.openReadingPipe(1, Pipe_Address_2);
  //----------------------------------------

  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Waiting for");
  lcd.setCursor(0,1);
  lcd.print("incoming data...");
  delay(1000);
}
//________________________________________________________________________________

//________________________________________________________________________________VOID LOOP()
void loop() {
  // put your main code here, to run repeatedly:

  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= sendIntervalMillis) {
    previousMillis = currentMillis;

    // Calls the send() subroutine.
    send_Data();
  }

  // Calling the receive_Data() subroutine.
  receive_Data();

  // Calling the show_Data() subroutine.
  show_Data();
}
//________________________________________________________________________________

//________________________________________________________________________________Read_Switches_State()
// Subroutine to get the state of the Switches.
void Read_Switches_State() {
  dataToSend.Switch_1_State = digitalRead(Switch_1_PIN);
  dataToSend.Switch_2_State = digitalRead(Switch_2_PIN);

  Serial.println("-------------Read_Switches_State()");
  Serial.print(F("Switch_1 : "));
  Serial.print(dataToSend.Switch_1_State);
  Serial.print(F(" | Switch_2 : "));
  Serial.println(dataToSend.Switch_2_State);
  Serial.println("-------------");
}
//________________________________________________________________________________

//________________________________________________________________________________send_Data()
// Subroutine for sending data.
void send_Data() {
  // Calls the Read_Switches_State() subroutine.
  Read_Switches_State();
    
  //----------------------------------------
  // Set the nRF24L01 module as the sender.
  radio.stopListening();
  
  bool rslt;

  // Always use sizeof() as it gives the size as the number of bytes.
  // For example if dataToSend was an int sizeof() would correctly return 2
  rslt = radio.write(&dataToSend, sizeof(Data_Package_Send));
  //----------------------------------------

  //----------------------------------------
  Serial.println("-------------");
  Serial.print("Master | Data Sent : ");
  Serial.print(dataToSend.Switch_1_State);
  Serial.print(",");
  Serial.print(dataToSend.Switch_2_State);
  if (rslt) {
    Serial.println(" | Acknowledge received");
  }
  else {
    Serial.println(" | Failed to send data !");
  }
  Serial.println("-------------");
  //----------------------------------------
}
//________________________________________________________________________________

//________________________________________________________________________________receive_Data()
// Subroutine for receiving data.
void receive_Data() {
  // Set the nRF24L01 module as the receiver.
  radio.startListening();
  
  if (radio.available()) {
    radio.read(&dataReceived, sizeof(Data_Package_Receive));
    newData = true;
  }
}
//________________________________________________________________________________

//________________________________________________________________________________show_Data()
// Subroutine for printing the received data to the serial monitor (serial communication) & LCD 16x2.
void show_Data() {
  if (newData == true) {
    Serial.println("-------------");
    Serial.print("Master | Data received : ");
    Serial.print(dataReceived.Status_Read_Sensor);
    Serial.print(",");
    Serial.print(dataReceived.Temp);
    Serial.print(",");
    Serial.println(dataReceived.Humd);
    Serial.println("-------------");
    Serial.println();
    Serial.println();

    if (dataReceived.Status_Read_Sensor == 1) {
      lcd.clear();
      lcd.setCursor(0,0);
      lcd.print("Temp : ");
      lcd.print(dataReceived.Temp);
      lcd.print(" ");
      lcd.write(degree_Char_Num);
      lcd.print("C");
      lcd.setCursor(0,1);
      lcd.print("Humd : ");
      lcd.print(dataReceived.Humd);
      lcd.print(" %");
    }
    if (dataReceived.Status_Read_Sensor == 0) {
      lcd.clear();
      lcd.setCursor(0,0);
      lcd.print("Temp : Err");
      lcd.setCursor(0,1);
      lcd.print("Humd : Err");
    }
    
    newData = false;
  }
}
//________________________________________________________________________________
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<





//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 08_Final_Slave (DHT11_and_LEDs)

// Reference : https://forum.arduino.cc/t/simple-nrf24l01-2-4ghz-transceiver-demo/405123/4

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The master sends data (state data of Switch_1 and Switch_2 to control LED_1 and LED_2 on the slave) to the slave.            //
// After the slave receives data from the master,                                                                               //
// the slave sends data (sensor reading status, temperature and humidity values obtained from the DHT11 sensor) to the master.  //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//----------------------------------------Including the libraries.
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
#include "DHT.h"
//----------------------------------------

// Defines CE and CSN PINs.
#define CE_PIN  9
#define CSN_PIN 10

// // Defines the DHT11 PIN and DHT sensor type.
#define DHTPIN  4
#define DHTTYPE DHT11

// Defines the PIN for the LEDs.
#define LED_1_PIN   2
#define LED_2_PIN   3

//----------------------------------------Address through which two modules communicate.
////////////////////////////////////////////////////
// Slave ----(Pipe_Address_2=00002)----> Master   //
// Slave <---(Pipe_Address_1=00001)----- Master   //
////////////////////////////////////////////////////
const byte Pipe_Address_1[6] = "00001";
const byte Pipe_Address_2[6] = "00002";
//----------------------------------------

//----------------------------------------Struct variables for receiving and sending data.
// Max size of this struct is 32 bytes - NRF24L01 buffer limit.
// This struct must match with the struct on the master.

//::::::::::::::::::Variables to hold the data to be received.
struct Data_Package_Receive {
  bool Switch_1_State;
  bool Switch_2_State;
};
Data_Package_Receive dataReceived; // Create a variable with the above structure.
//::::::::::::::::::

//::::::::::::::::::Variables to hold the data to be sent.
struct Data_Package_Send {
  bool  Status_Read_Sensor;
  float Temp;
  int   Humd;
};
Data_Package_Send dataToSend; // Create a variable with the above structure.
//::::::::::::::::::
//----------------------------------------

// Variables to detect new incoming data.
bool newData = false;

// Create an RF24 object as a radio, while also setting the CE and CSN PINs.
RF24 radio(CE_PIN, CSN_PIN); // CE, CSN

// Create a DHT object as dht11 and set the DHT PIN and DHT sensor type.
DHT dht11(DHTPIN, DHTTYPE);

//________________________________________________________________________________VOID SETUP()
void setup() {
  // put your setup code here, to run once:

  Serial.begin(115200);
  Serial.println();
  delay(2000);

  Serial.println("This is Slave");
  Serial.println();

  //----------------------------------------LEDs and dht11 Setup.
  pinMode(LED_1_PIN, OUTPUT);
  pinMode(LED_2_PIN, OUTPUT);

  digitalWrite(LED_1_PIN, LOW);
  digitalWrite(LED_2_PIN, LOW);

  // Initialize dht11.
  dht11.begin();
  //----------------------------------------

  //----------------------------------------nRF24L01 Setup.
  // initialize the radio object.
  radio.begin();

  // set the Power Amplifier level.
  // Use "RF24_PA_MIN" or "RF24_PA_LOW" if the distance between nRF24L01 modules is close to each other.
  // Use "RF24_PA_HIGH" or "RF24_PA_MAX" if the distance between nRF24L01 modules is far from each other.
  // For more details, see here : https://github.com/nRF24/RF24/blob/master/RF24.h#L26C1-L26C1
  radio.setPALevel(RF24_PA_LOW);
  
  // Set the transmission datarate.
  radio.setDataRate(RF24_250KBPS); // (RF24_250KBPS|RF24_1MBPS|RF24_2MBPS).

  // Set the number and delay of retries upon failed submit.
  radio.setRetries(5,5); // setRetries(delay,count).

  // Set the nRF24L01 module as the sender.
  radio.stopListening();

  // Set the address to send data to the receiver. The receiver must use the same address.
  // Slave ----(Pipe_Address_2=00002)----> Master
  radio.openWritingPipe(Pipe_Address_2);

  // Set the address to receive data from the sender. The sender must use the same address.
  // Slave <---(Pipe_Address_1=00001)----- Master
  radio.openReadingPipe(1, Pipe_Address_1);
  //----------------------------------------
}
//________________________________________________________________________________

//________________________________________________________________________________VOID LOOP()
void loop() {
  // put your main code here, to run repeatedly:

  // Calling the receive_Data() subroutine.
  receive_Data();

  // Calling the show_Data() subroutine.
  show_Data();

  // Calls the send_Data() subroutine.
  send_Data();
}
//________________________________________________________________________________

//________________________________________________________________________________Getting_DHT11_Sensor_Data()
// Subroutine for getting temperature and humidity data from the DHT11 sensor.
void Getting_DHT11_Sensor_Data() {
  // Reading temperature or humidity takes about 250 milliseconds!
  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)
  int h = dht11.readHumidity();
  // Read temperature as Celsius (the default)
  float t = dht11.readTemperature();

  bool srs;

  // Check if any reads failed and exit early (to try again).
  if (isnan(h) || isnan(t)) {
    Serial.println(F("Failed to read from DHT sensor!"));
    srs = false;
    h = 0;
    t = 0.0;
  } else {
    srs = true;
  }

  Serial.println("-------------Getting_DHT11_Sensor_Data()");
  Serial.print(F("SRS : "));
  Serial.print(srs);
  Serial.print(F(" | Humidity : "));
  Serial.print(h);
  Serial.print(F("% | Temperature : "));
  Serial.print(t);
  Serial.println(F("°C"));
  Serial.println("-------------");

  dataToSend.Humd = h;
  dataToSend.Temp = t;
  dataToSend.Status_Read_Sensor = srs;
}
//________________________________________________________________________________

//________________________________________________________________________________receive_Data()
// Subroutine for receiving data.
void receive_Data() {
  // Set the nRF24L01 module as the receiver.
  radio.startListening();
  
  if (radio.available()) {
    radio.read(&dataReceived, sizeof(Data_Package_Receive));
    newData = true;
  }
}
//________________________________________________________________________________

//________________________________________________________________________________show_Data()
// Subroutine for printing the received data to the serial monitor (serial communication).
void show_Data() {
  if (newData == true) {
    Serial.println("-------------");
    Serial.print("Slave | Data received : ");
    Serial.print(dataReceived.Switch_1_State);
    Serial.print(",");
    Serial.println(dataReceived.Switch_1_State);
    Serial.println("-------------");

    if (dataReceived.Switch_1_State == 0) digitalWrite(LED_1_PIN, HIGH);
    if (dataReceived.Switch_1_State == 1) digitalWrite(LED_1_PIN, LOW);
    if (dataReceived.Switch_2_State == 0) digitalWrite(LED_2_PIN, HIGH);
    if (dataReceived.Switch_2_State == 1) digitalWrite(LED_2_PIN, LOW);
  }
}
//________________________________________________________________________________

//________________________________________________________________________________send_Data()
// Subroutine for sending data.
void send_Data() {
  if (newData == true) {
    // Calls the Getting_DHT11_Sensor_Data() subroutine.
    Getting_DHT11_Sensor_Data();
    
    //----------------------------------------
    // Set the nRF24L01 module as the sender.
    radio.stopListening();
    
    bool rslt;
  
    // Always use sizeof() as it gives the size as the number of bytes.
    // For example if dataToSend was an int sizeof() would correctly return 2
    rslt = radio.write(&dataToSend, sizeof(Data_Package_Send));
    //----------------------------------------
  
    //----------------------------------------
    Serial.println("-------------");
    Serial.print("Slave | Data Sent : ");
    Serial.print(dataToSend.Status_Read_Sensor);
    Serial.print(",");
    Serial.print(dataToSend.Temp);
    Serial.print(",");
    Serial.print(dataToSend.Humd);
    if (rslt) {
      Serial.println(" | Acknowledge received");
    }
    else {
      Serial.println(" | Failed to send data !");
    }
    Serial.println("-------------");
    Serial.println();
    Serial.println();
    //----------------------------------------
  
    newData = false;
  }
}
//________________________________________________________________________________
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
